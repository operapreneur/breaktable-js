{"version":3,"sources":["breaktable.js"],"names":["breakTableContainers","document","querySelectorAll","lengthBreakTables","length","addEventListener","getBreakTableContainers","i","table","getElementsByTagName","l","dataset","breaktables","btcolumns","buildBreakTables","console","log","iBTcontainer","btClass","setBTclassName","btID","setBTidName","breakcolumns","JSON","parse","newTables","parseInt","t","createElement","className","id","tableNode","addBTchildren","closest","appendChild","btclass","btidentifier","newIndex","tableIndex","children","tagName","child","addBTrows","childIndex","childNode","rowIndex","rows","btid","getBTrowTrue","row","addBTrow","getBTcells","rowsIndex","str","array","includes","index","rowNode","columnIndex","cell","cellInterval","cellIndex","getBTcellTagName","appendCell","scope","getBTcellScope","getBTcellColSpan","element","addBTcell","colSpan","spanLength","spanMax","innerHTML"],"mappings":"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","file":"bundle.js","sourcesContent":["// Basic Table rules\n// 1. Scope is only added to <th> elements\n\n// data-breaktables=\"popup|integer\"\n// data-btcolumns=\"integer\"\n// data-btclass=\"broken-table|string\"\n// data-btidentifier=\"bt-[index]|inherit|string\"\n// data-btid=\"integer\"\n\nconst breakTableContainers = document.querySelectorAll('.breaktableJS');\nconst lengthBreakTables = breakTableContainers.length;\n\n// Handler when the DOM is fully loaded\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n\n  // Search doc for breaktable containers\n  if (breakTableContainers) { getBreakTableContainers(); }\n\n});\n\n// Iterate over all breaktables\nconst getBreakTableContainers = () => {\n  for (let i = 0; i < lengthBreakTables; i++) {\n    let table = breakTableContainers[i].getElementsByTagName(\"table\");\n    let l = table.length;\n\n    if (l === 1){\n\n      if (table[0].dataset.breaktables) {\n        if (table[0].dataset.btcolumns) {\n          buildBreakTables(i, table[0]);\n        } else {\n          console.log(\"data-btcolumns must be set on the table\");\n        }\n      } else {\n        console.log(\"data-breaktable must be set on the table\");\n      }\n\n    } else {\n      console.log(\"breakTableContainers must contain one table only\");\n    }\n  }\n}\n\n// Return new tables\nconst buildBreakTables = (iBTcontainer, table) => {\n  // console.dir(table);\n\n  // SET table class name\n  let btClass = setBTclassName(table)\n\n  // SET table ID name\n  let btID = setBTidName(iBTcontainer, table)\n\n  // SET total tables +1 for readable id names\n  let breakcolumns = JSON.parse(\"[\" + table.dataset.breaktables + \"]\");\n  let newTables = parseInt(breakcolumns.length) + 1;\n\n  // table.btcolumns\n\n  // CREATE new tables\n  for (let i = 1; i < newTables; i++) {\n    let t = document.createElement('table');\n    t.className = btClass;\n    t.id = btID + '-' + [i];\n\n    let tableNode = t;\n\n    // args rule: parent > interval > child\n    addBTchildren(breakcolumns, table, i, tableNode);\n\n    // console.log(tableNode);\n    // console.dir(tableNode);\n    table.closest('.breaktableJS').appendChild(tableNode);\n  } // END for loop\n}\n\n// SET table class name: data-btclass=\"broken-table|string\"\nconst setBTclassName = (table) => {\n  let className = table.dataset.btclass;\n  return (className) ? className : \"broken-table\";\n}\n\n// SET table ID: data-btidentifier=\"bt-[index]|inherit|string\"\nconst setBTidName = (iBTcontainer, table) => {\n  let id;\n  if (table.dataset.btidentifier) {\n    id = table.dataset.btidentifier;\n  } else if (table.id) {\n    id = table.id;\n  } else {\n    // if no ID use table index +1 for readable id names\n    let newIndex = iBTcontainer + 1;\n    id = 'bt' + '-' + newIndex;\n  }\n  return id;\n}\n\n// ADD table children\nconst addBTchildren = (breakcolumns, table, tableIndex, tableNode) => {\n  let l = table.children.length;\n  for (let i = 0; i < l; i++) {\n\n    // TODO: do not allow <colgroup>\n\n    let tagName = table.children[i].tagName;\n    let child = document.createElement(tagName);\n\n    tableNode.appendChild(child);\n\n    addBTrows(breakcolumns, tableIndex, tableNode, i, table.children[i]);\n  } // END for loop\n}\n\n// ADD table rows from child\nconst addBTrows = (breakcolumns, tableIndex, tableNode, childIndex, childNode) => {\n  let rowIndex = 0; // Due to ignored rows and rowSpan(?) the number of rows will not always equal the row loop interval\n  let rows = childNode.rows;\n  let l = childNode.rows.length;\n  for (let i = 0; i < l; i++) {\n\n    // TODO: if .rowSpan\n\n    // check if row has data-btid\n    if (rows[i].dataset.btid) {\n      let btid = getBTrowTrue(tableIndex, childNode, i);\n      // ADD row if data-btid is EQUAL to tableIndex\n      if (btid === true) {\n        let row = addBTrow(tableNode, childNode, i);\n        tableNode.children[childIndex].appendChild(row);\n        getBTcells(breakcolumns, tableIndex, tableNode, childIndex, rowIndex, rows[i]);\n        rowIndex ++;\n      } else {\n        continue;\n      }\n    } else {\n      let row = addBTrow(tableNode, childNode, i);\n      tableNode.children[childIndex].appendChild(row);\n      getBTcells(breakcolumns, tableIndex, tableNode, childIndex, rowIndex, rows[i]);\n      rowIndex ++;\n    }\n  } // END for loop\n}\n\n// RETURN rows equal to data-btid\nconst getBTrowTrue = (tableIndex, childNode, rowsIndex) => {\n  let str = childNode.rows[rowsIndex].dataset.btid;\n  let array = JSON.parse(\"[\" + str + \"]\");\n  if (array.includes(tableIndex)) {\n    return true;\n  }\n}\n\n// ADD table row\nconst addBTrow = (tableNode, child, index) => {\n  let tagName = child.rows[index].tagName;\n  let row = document.createElement(tagName);\n  if (child.rows[index].className) {\n    row.className = child.rows[index].className;\n  }\n  return row;\n}\n\n// GET table cells\nconst getBTcells = (breakcolumns, tableIndex, tableNode, childIndex, rowIndex, rowNode) => {\n  let l = rowNode.children.length;\n  let columnIndex = tableIndex - 1;\n  columnIndex = breakcolumns[columnIndex]\n\n  for (let i = 0; i < l; i++) {\n    let cell = rowNode.children[i];\n\n    let cellInterval = i+1;\n    let cellIndex = cell.cellIndex + 1;\n    let tagName = getBTcellTagName(cell);\n\n    let appendCell = false;\n\n    if (tagName === true ) { // if <th>\n      let scope = getBTcellScope(cell);\n      if (scope === 'col') {\n        // cell = TH && scope=col\n        appendCell = getBTcellColSpan(columnIndex, cellInterval, cellIndex, cell, appendCell);\n      } else {\n        // cell = TH && scope=row\n        appendCell = true;\n      }\n    } else {\n      // cell = TD\n      appendCell = getBTcellColSpan(columnIndex, cellInterval, cellIndex, cell, appendCell);\n    }\n\n    if (appendCell === true) {\n      let element = addBTcell(cell)\n      tableNode.children[childIndex].rows[rowIndex].appendChild(element);\n    }\n  }\n\n}\n\nconst getBTcellTagName = cell => (cell.tagName == 'TH') ? true : false;\nconst getBTcellScope = cell => cell.scope;\n\nconst getBTcellColSpan = (columnIndex, cellInterval, cellIndex, cell, appendCell) => {\n  let colSpan = cell.colSpan;\n\n  if (colSpan >= 2 ) {\n    let spanLength = colSpan - 1;\n    let spanMax = cellIndex + spanLength\n    if ((cellIndex == cellInterval) && (columnIndex == cellInterval)) {\n      appendCell = true;\n    } else if ((spanMax >= columnIndex) && (columnIndex > cellInterval)) {\n      appendCell = true;\n    } else {\n      appendCell = false;\n    }\n  } else {\n    if (columnIndex == cellInterval) {\n      appendCell = true;\n    }\n  }\n  return appendCell;\n}\n\n// ADD table cell\nconst addBTcell = (cell) => {\n  let tagName = cell.tagName;\n  let element = document.createElement(tagName);\n  element.innerHTML = cell.innerHTML;\n\n  return element;\n}\n"]}